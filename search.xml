<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2025/09/12/about/</url>
    <content><![CDATA[<blockquote>
<p>A developer, live in Guizhou, China.</p>
</blockquote>
<p> 姓名：徐梦铃</p>
<p> QQ: 298424075</p>
<p> 微信：Qw15935726840As</p>
<p> github:<a href="https://github.com/dashboard">Dashboard</a></p>
<p> gitee:<a href="https://gitee.com/qw_28_0">Admin</a></p>
<span id="more"></span>

<p>​      </p>
<p>​                                                                         <img src="https://pic1.zhimg.com/v2-0dda71bc9ced142bf7bb2d6adbebe4f0_r.jpg?source=1940ef5c" style="border-radius:50%;width:250px;height:250px; " /></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2025/09/10/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h3><p><strong>栈的定义</strong>：栈（Stack）是一种<strong>运算受限的线性表</strong>，只允许在一端进行插入或删除操作。这一端被称为<strong>栈顶</strong>（Top），相对地，另一端称为<strong>栈底</strong>（Bottom）。栈的特点是<strong>后进先出</strong>（Last In First Out，简称 LIFO），即最后插入的元素最先被删除。如下图：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190426/1I203KK-1.gif"></p>
<h4 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h4><p>与线性表类似，栈的存储结构也分为两种，即<strong>顺序存储</strong>和<strong>链式存储</strong>，顺序存储的栈称为顺序栈，链式存储的栈称为链式栈<span id="more"></span></p>
<h5 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h5><img src="https://pica.zhimg.com/v2-4c5516b6ecdccdaeb38dd88f5b415b56_1440w.jpg" style="zoom: 33%;" />

<ol>
<li><p><strong>顺序栈的存储结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">	Elemtype data[MaxSize];</span><br><span class="line">&#125;;</span><br><span class="line">SeqStack *s; <span class="comment">//定义一个栈</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>顺序栈的基本运算</strong></p>
<img src="https://pic1.zhimg.com/v2-bbafbd4f41009550d7060fcf0f45241c_1440w.jpg" style="zoom: 67%;" />

<p>（1）栈的初始化（置空栈）</p>
<p>通常将一维数组的<strong>0 下标端设为栈底</strong>，这样<strong>空栈</strong>时栈顶指针 <strong>s-&gt;top&#x3D;-1</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SeqStack <span class="title function_">init_Stack</span><span class="params">()</span>&#123;</span><br><span class="line">	SeqStack s=(SeqStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seqStack));</span><br><span class="line">	<span class="keyword">if</span>(!s) 	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	s-&gt;top=<span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）判断是否为空栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(SeqStack s)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span>  (s-&gt;top==<span class="number">-1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）销毁栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryStack</span><span class="params">(SeqStack s)</span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈已销毁&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）<strong>入栈（进栈操作）</strong></p>
<p>在进栈之前，需要判断<strong>是否栈满（s-&gt;top&#x3D;&#x3D;maxsize)</strong>，这是做进栈操作会产生空间溢出现象，称为<strong>上溢</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(SeqStack s,Elemtype x)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==MaxSize)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈上溢&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s-&gt;top++;</span><br><span class="line">	s-&gt;data[s-&gt;top]=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）<strong>出栈（退栈操作）</strong></p>
<p>在出栈之前，需要判断是否栈空（IsEmpty(s))，这是做出栈操作会产生<strong>下溢</strong>现象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elemtype <span class="title function_">Pop</span><span class="params">(SeqStack s)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(s))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈下溢&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Elemtype x=s-&gt;data[s-&gt;top];</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）读取栈顶元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(SeqStack s)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h5><img src="https://pic2.zhimg.com/v2-3386eb991890918c0c344e91f62c5839_1440w.jpg" style="zoom: 67%;" />

<ol>
<li><p><strong>链式栈的存储结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">next</span>;</span></span><br><span class="line">	Elemtype data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Stack* LinkStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链式栈的操作及运算</strong></p>
<p>可类比上文顺序栈进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkStack <span class="title function_">init_Stack</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkStack top;</span><br><span class="line">	top=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkStack <span class="title function_">Push</span><span class="params">(LinkStack top,Elemtype x)</span>&#123;</span><br><span class="line">	LinkStack p=(LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	p-&gt;data=x;</span><br><span class="line">	p-&gt;next=top;</span><br><span class="line">	top=p;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkStack <span class="title function_">Pop</span><span class="params">(LinkStack top,Elemtype* x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top)&#123;</span><br><span class="line">		LinkStack temp=top;</span><br><span class="line">		*x=top-&gt;data;<span class="comment">//通过指针将top-&gt;data传给实参</span></span><br><span class="line">		top=top-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		<span class="keyword">return</span> top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elemtype <span class="title function_">GetTop</span><span class="params">(LinkStack top)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top ? top-&gt;data : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="队列又是什么？"><a href="#队列又是什么？" class="headerlink" title="队列又是什么？"></a>队列又是什么？</h3><p><strong>队列的定义</strong>：<strong>队列（queue）是一种采用<a href="FIFO">先进先出</a>策略的抽象数据结构，即最先进队列的数据元素，同样要最先[出队]列</strong>。队列跟我们排队买票一样，先来排队的肯定先买票，后来排队的的后买到票，如下图：</p>
<img src="https://picx.zhimg.com/v2-f52f5afb6d816922eaa0dadde0cb8925_r.jpg" style="zoom: 50%;" />

<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><p>队列的存储结构与栈同样分为<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p>
<h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><p>队列的顺序存储结构是指在内存分配一段连续的存储单元存放队列元素，并附设两个指针：<strong>队头指针</strong>-<strong>front</strong> 指向队头和<strong>队位指针</strong>-<strong>rear</strong>指向下一个元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    Elemtype data[Maxsize];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：由于顺序队列的运算与循环队列的运算相似，所有这里不再过多赘述，可以直接参考下面循环队列运算的思想和方法。</p>
<h5 id="存在的问题（弊端）？"><a href="#存在的问题（弊端）？" class="headerlink" title="存在的问题（弊端）？"></a>存在的问题（弊端）？</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a270e40949b4d3253e3d8e2fe42ae38.png"></p>
<p>出队 a1、a2，则 front 指针指向下标为 2 的位置，rear 不变，如左图所示，再入队 a5,此时 front 指针不变，rear 指针移动到数组之外，那么就会产生数组越界的错误，可实际上，我们的队列在下标为 0 和 1 的地方还是空闲的。我们把这种现象叫做 “假溢出”。如右图所示。<a href="https://blog.csdn.net/weixin_43800761/article/details/107313622">原文链接</a>（参考）</p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列是一种<strong>先进先出</strong>（FIFO）的数据结构，它通过<strong>将顺序队列的末尾连接到开头，形成一个环状结构</strong>，从而解决了顺序队列的<strong>虚假满状态问题</strong>。     <img src="https://developer.qcloudimg.com/http-save/yehe-11396077/fc95b7859f9b8adcecb669a1add0b73c.png" style="zoom: 67%;" /></p>
<h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">	Elemtype *data;</span><br><span class="line">	<span class="type">int</span> front;</span><br><span class="line">	<span class="type">int</span> rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Queue* SeqQueue;</span><br></pre></td></tr></table></figure>

<h5 id="循环队列基本操作"><a href="#循环队列基本操作" class="headerlink" title="循环队列基本操作"></a>循环队列基本操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SeqQueue <span class="title function_">Init_Queue</span><span class="params">()</span>&#123;</span><br><span class="line">	SeqQueue p=(SeqQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">	p-&gt;data=(Elemtype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elemtype)*MaxSize);</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;data==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	p-&gt;front=<span class="number">0</span>;</span><br><span class="line">	p-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">SeqQueue <span class="title function_">EnQueue</span><span class="params">(SeqQueue p,Elemtype x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;front==(p-&gt;rear+<span class="number">1</span>)%MaxSize)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>) ;</span><br><span class="line">	&#125; </span><br><span class="line">	p-&gt;data[p-&gt;rear]=x;</span><br><span class="line">	p-&gt;rear=(p-&gt;rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">SeqQueue <span class="title function_">DeQueue</span><span class="params">(SeqQueue p,Elemtype *x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;front==p-&gt;rear)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	*x=p-&gt;data[p-&gt;front];</span><br><span class="line">	p-&gt;front=(p-&gt;front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">Elemtype  <span class="title function_">GetTop</span><span class="params">(SeqQueue p)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (p-&gt;front==p-&gt;rear)? <span class="number">0</span> : p-&gt;data[p-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestoryQueue</span><span class="params">(SeqQueue p)</span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(p-&gt;data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队列已销毁，空间已释放&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(SeqQueue p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;front==p-&gt;rear)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空队列&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);	 </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;循环队列遍历（对头-&gt;队尾）\n&quot;</span>); </span><br><span class="line">	<span class="comment">//从队头指针遍历到队尾指针处，完成遍历 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p-&gt;front; p-&gt;rear!=i%MaxSize; i=(i+<span class="number">1</span>)%MaxSize)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p><strong>链表是一种动态数据结构</strong>，可以方便地进行插入和删除操作。使用链表实现队列可以避免数组实现中的容量限制问题，并且操作效率较高。</p>
<h5 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><p>链式队列的实现通常涉及到两个指针：一个指向队列的头部（队首元素的前一个位置），另一个指向队列的尾部（队尾元素）。<strong>当队列为空时，这两个指针都指向队列的头结点。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span>&#123;</span></span><br><span class="line">	QueueNode* front;</span><br><span class="line">	QueueNode* rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="链式队列的运算"><a href="#链式队列的运算" class="headerlink" title="链式队列的运算                      "></a>链式队列的运算                      <img src="https://c.biancheng.net/uploads/allimg/190426/1I5396159-1.gif"></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LinkQueue* <span class="title function_">Init_Queue</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkQueue *Q=(LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue));</span><br><span class="line">	QueueNode *p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=p;</span><br><span class="line">	Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">LinkQueue* <span class="title function_">EnQueue</span><span class="params">(LinkQueue* Q ,Elemtype x)</span>&#123;</span><br><span class="line">	QueueNode *p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	p-&gt;data=x;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear-&gt;next=p;</span><br><span class="line">	Q-&gt;rear=p;</span><br><span class="line">	<span class="keyword">return</span> Q ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">LinkQueue* <span class="title function_">DeQueue</span><span class="params">(LinkQueue* Q,Elemtype *x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	QueueNode* p=Q-&gt;front-&gt;next;</span><br><span class="line">	*x=p-&gt;data;</span><br><span class="line">	Q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="comment">//注意：当p为队列中最后一个节点时，出队应将队列置空</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==p)</span><br><span class="line">	Q-&gt;rear=Q-&gt;front;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elemtype <span class="title function_">GetHead</span><span class="params">(LinkQueue* Q)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q-&gt;front==Q-&gt;rear)? <span class="number">0</span> : Q-&gt;front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链式队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkQueue *Q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空队列&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链式队列遍历（对头-&gt;队尾）\n&quot;</span>);</span><br><span class="line">	QueueNode* q=Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,q-&gt;data);</span><br><span class="line">    	q=q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\b\b \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestoryQueue</span><span class="params">(LinkQueue* Q)</span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链式队列已销毁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2025/09/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是一种基本的数据结构，它包含一系列的数据元素，这些元素之间存在一对一的顺序关系。线性表可以有多种不同的存储结构，如<strong>顺序存储</strong>结构和<strong>链式存储结构</strong>，每种结构都有其特定的操作方法和适用场景。</p>
<h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><h5 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h5><p>在定义一个线性表时，需要先定义一个数组来存储线性表中所有元素，并定义一个整型变量来存储线性表的长度。以下代码定义了一个顺序表：<strong>sqlist</strong> L;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqList</span>&#123;</span></span><br><span class="line">	Elemtype data[Maxsize];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="顺序表的基本运算"><a href="#顺序表的基本运算" class="headerlink" title="顺序表的基本运算"></a>顺序表的基本运算</h5><ol>
<li><p>顺序表的初始化：</p>
<p>为顺序表申请一段地址空间，并置空该表。线性表的存储空间可以通过<strong>malloc( sizeof ( Sqlist ) )</strong> 动态分配获得,如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化列表，构造一个空的顺序列表</span></span><br><span class="line">sqList *<span class="title function_">init_list</span><span class="params">()</span>&#123;</span><br><span class="line">	sqList * L;</span><br><span class="line">	<span class="comment">//动态分配内存</span></span><br><span class="line">	L=(sqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sqList));</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	L-&gt;length=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入运算:</p>
<p>顺序表的插入是指在线性表的第 <strong>i</strong> 个元素位置上插入一个值为 x 的新元素，插入后是原来的表长为 <strong>n+1</strong>（设原来表长为 <strong>n</strong> )。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表插入运算</span></span><br><span class="line">sqList *<span class="title function_">insertItem</span><span class="params">(sqList *L, <span class="type">int</span> i,Elemtype x)</span>&#123;</span><br><span class="line">	<span class="comment">//判断i的取值是否符合范围</span></span><br><span class="line">	<span class="keyword">if</span>(i&gt;L-&gt;length||i&lt;<span class="number">1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//判断表格满益</span></span><br><span class="line">	<span class="keyword">if</span>(L-&gt;length&gt;=Maxsize) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="comment">//确定i的位置，后序的数据下标加 1 ；</span></span><br><span class="line">	<span class="keyword">for</span>(m=L-&gt;length<span class="number">-1</span>;m&gt;=i<span class="number">-1</span>;m--)&#123;</span><br><span class="line">		L-&gt;data[m+<span class="number">1</span>]=L-&gt;data[m];</span><br><span class="line">		L-&gt;data[i<span class="number">-1</span>]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length++;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：从代码健壮的角度考虑，设计算法时需要考虑取值<strong>范围是否符合，表格满益</strong>问题。</p>
</li>
<li><p>删除运算：</p>
<p>顺序表的删除是指在线性表的将第 <strong>i</strong> 个元素从顺序表中上去掉，删除后是原来的表长为 <strong>n-1</strong>（设原来表长为 <strong>n</strong> )。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">sqList * <span class="title function_">removeItem</span><span class="params">(sqList *L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="comment">//判断i的取值是否符合范围</span></span><br><span class="line">	<span class="keyword">if</span>(i&gt;L-&gt;length||i&lt;<span class="number">1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	Elemtype x=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m=i;m&lt;=L-&gt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		L-&gt;data[m<span class="number">-1</span>]=L-&gt;data[m];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length--;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>按值查找：</p>
<p>线性表的查找是指在线性表中查找与给定值 <strong>x</strong> 相等的数据元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表的安置查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findItem</span><span class="params">(sqList *L,Elemtype x)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L-&gt;data[i]==x)&#123;</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><p>在链式存储结构中，线性表的结点存储地址<strong>可以是连续的，也可以是不连续的</strong>。这是链式存储的一个显著特点，与顺序存储结构不同。</p>
<p>链式存储通过指针域来维护结点之间的逻辑关系。每个结点包含两个部分：<strong>数据域</strong>和<strong>指针域</strong>。指针域存储下一个结点的地址，因此即使物理存储单元不连续，逻辑上仍然可以保持数据的顺序。</p>
<p>这种存储方式的优点是：</p>
<ul>
<li><strong>灵活性高</strong>：不需要预先分配连续的存储空间，适合存储动态变化的数据。</li>
<li><strong>插入和删除操作效率高</strong>：无需移动大量数据，只需调整指针即可。</li>
</ul>
<p>需要注意的是，虽然结点之间的存储地址可以不连续，但<strong>结点内部的数据域和指针域是连续的</strong>，因为它们通常被封装在一个结构体或对象中。</p>
<p>总结来说，线性表采用链式存储时，结点的存储地址<strong>连续与否均可</strong>，这也是链式存储的核心特性之一。</p>
<p>根据链接方式的不同，链表可以分为单链表，循环链表，双向链表。下面将分别介绍各种链表及其运算的实现。</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><h5 id="单链表存储结构"><a href="#单链表存储结构" class="headerlink" title="单链表存储结构"></a>单链表存储结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	Elemtype data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> LNode * linkList ;</span><br><span class="line">linkList head <span class="comment">//head为单链表的头指针</span></span><br></pre></td></tr></table></figure>

<h5 id="单链表的运算"><a href="#单链表的运算" class="headerlink" title="单链表的运算"></a>单链表的运算</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">linkList <span class="title function_">init_list</span><span class="params">()</span>&#123;</span><br><span class="line">	linkList L;</span><br><span class="line">	L=(linkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//建立一个空表</span></span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法添加元素（会导致数据逆向添加）</span></span><br><span class="line">linkList <span class="title function_">insert_head</span><span class="params">(linkList L,Elemtype x)</span>&#123;</span><br><span class="line">	linkList p;</span><br><span class="line">	p=(linkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//为新节点分配存储空间</span></span><br><span class="line">	p-&gt;data=x;</span><br><span class="line">	p-&gt;next=L-&gt;next;  <span class="comment">//修改链表关系</span></span><br><span class="line">	L-&gt;next=p;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">！！！注意：虽然头插法较为简单，但是读入数据顺序与生成的链表中元素的顺序是相反的</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法添加元素（常用）</span></span><br><span class="line">linkList <span class="title function_">inser_end</span><span class="params">(linkList L,Elemtype x)</span>&#123;</span><br><span class="line">	linkList p;</span><br><span class="line">	p=(linkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	p-&gt;data=x;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	L-&gt;next=p;</span><br><span class="line">	<span class="keyword">return</span> p;  <span class="comment">//将尾节点返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置插入节点</span></span><br><span class="line">linkList <span class="title function_">insertNode</span><span class="params">(linkList L,<span class="type">int</span> i,Elemtype x)</span>&#123;</span><br><span class="line">	<span class="comment">//在带表头节点找到i-1位置的节点</span></span><br><span class="line">	linkList p,s;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//创建新节点</span></span><br><span class="line">	s=(linkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line">linkList <span class="title function_">removeNode</span><span class="params">(linkList L,<span class="type">int</span> i，Elemtype &amp;e)</span>&#123;</span><br><span class="line">	linkList p,s;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	s=p-&gt;next;</span><br><span class="line">	p-&gt;next=s-&gt;next;</span><br><span class="line">	x=s-&gt;data; <span class="comment">//保存被删除节点的值</span></span><br><span class="line">	<span class="built_in">free</span>(s);  <span class="comment">//释放空间</span></span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找（根据值查找）</span></span><br><span class="line">linkList <span class="title function_">getSite</span><span class="params">(linkList L,Elemtype x)</span>&#123;</span><br><span class="line">	linkList p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历(返回表长)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_list</span><span class="params">(linkList L)</span>&#123;</span><br><span class="line">	linkList p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p-&gt;data);</span><br><span class="line">  		p=p-&gt;next;</span><br><span class="line">  		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表是一种链表数据结构，其中最后一个节点的指针不是指向<em>NULL</em>，而是指向链表的头节点，形成一个闭环。这种结构的链表允许我们从链表中的任何一个节点出发，都能遍历整个链表。</p>
<p>单向循环链表的数据类型定义与单链表相同，并且运算操作也基本相同。区别在于：</p>
<p><strong>*（1）判断是否为空：*</strong></p>
<p>单向链表：如果头结点指向空，那么为空链表</p>
<p>单向循环链表：如果头结点指向自身，那么为空链表</p>
<p><strong>*（2）判断是否为尾结点*</strong></p>
<p>单向链表：指向空的节点为尾结点</p>
<p>单向循环链表：指向头结点的节点为尾结点</p>
<h5 id="构造单向循环列表"><a href="#构造单向循环列表" class="headerlink" title="构造单向循环列表"></a>构造单向循环列表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造单向循环链表</span></span><br><span class="line">linklist <span class="title function_">createlist</span><span class="params">()</span>&#123;</span><br><span class="line">	linklist L;</span><br><span class="line">	L=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)) ;</span><br><span class="line">	L-&gt;next=L;</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		linklist p=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		p-&gt;data=n;</span><br><span class="line">		<span class="comment">//找到尾节点</span></span><br><span class="line">		linklist tail=L;</span><br><span class="line">		<span class="keyword">while</span>(tail-&gt;next!=L)&#123;</span><br><span class="line">			tail=tail-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		tail-&gt;next=p;</span><br><span class="line">		p-&gt;next=L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表是一种常见的线性数据结构，它由一系列节点组成，每个节点包含两个指针，一个指向前一个节点（<strong>prev</strong>指针），一个指向后一个节点（<strong>next</strong>指针）。与单链表相比，双向链表具有双向遍历、方便插入和删除、更灵活的操作等优势。</p>
<h5 id="双向链表的节点定义"><a href="#双向链表的节点定义" class="headerlink" title="双向链表的节点定义"></a>双向链表的节点定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">	Elemtype data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">prev</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DuLNode* doubleList;</span><br></pre></td></tr></table></figure>

<h5 id="双向链表的运算操作"><a href="#双向链表的运算操作" class="headerlink" title="双向链表的运算操作"></a>双向链表的运算操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">doubleList <span class="title function_">init_list</span><span class="params">()</span>&#123;</span><br><span class="line">	doubleList L=(doubleList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode));</span><br><span class="line">	<span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	L-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">doubleList <span class="title function_">tail_insert</span><span class="params">(doubleList L,Elemtype x)</span>&#123;</span><br><span class="line">	doubleList p=(doubleList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode));</span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	doubleList r=L;</span><br><span class="line">	p-&gt;data=x;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;prev=r;</span><br><span class="line">	r-&gt;next=p;</span><br><span class="line">	r=p;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">doubleList <span class="title function_">head_insert</span><span class="params">(doubleList L,Elemtype x)</span>&#123;</span><br><span class="line">	doubleList p=(doubleList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode));</span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">	p-&gt;next=L-&gt;next;</span><br><span class="line">	p-&gt;prev=L;</span><br><span class="line">	L-&gt;next=p;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line">doubleList <span class="title function_">InsertNode</span><span class="params">(doubleList L,<span class="type">int</span> i,Elemtype x)</span>&#123;</span><br><span class="line">	<span class="comment">//找到i-1位置上的前驱节点</span></span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(L-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		j++;</span><br><span class="line">		L=L-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>||j&gt;i) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	doubleList p=(doubleList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode));</span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	p-&gt;data=x;</span><br><span class="line">	p-&gt;next=L-&gt;next;</span><br><span class="line">	L-&gt;next-&gt;prev=p;</span><br><span class="line">	p-&gt;prev=L;</span><br><span class="line">	L-&gt;next=p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">doubleList <span class="title function_">RemoveNode</span><span class="params">(doubleList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="comment">//找到i位置的节点</span></span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(L-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">		j++;</span><br><span class="line">		L=L-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>||j&gt;i) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	doubleList s=L;</span><br><span class="line">	Elemtype x=s-&gt;data;</span><br><span class="line">    s-&gt; prev-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next-&gt;prev=s-&gt;prev;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="1-顺序表与链表的区别"><a href="#1-顺序表与链表的区别" class="headerlink" title="1.顺序表与链表的区别"></a>1.顺序表与链表的区别</h4><p>顺序表和链表是两种基本的数据结构，它们在存储数据和实现数据操作上各有特点和优势。顺序表是一种连续存储的结构，通常使用数组实现，而链表则由一系列不连续存储的节点组成，每个节点通过指针相连。</p>
<h5 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h5><p>顺序表的主要特点是<strong>它允许快速的随机访问，即可以直接通过下标索引来访问任何位置的元素</strong>，这使得访问效率非常高，时间复杂度为 O(1)。此外，顺序表的<strong>存储密度高</strong>，因为它不需要额外的空间来存储节点间的指针。然而，顺序表的缺点在于<strong>插入和删除操作需要移动大量元素</strong>，特别是在表的中间或开始位置进行这些操作时，时间复杂度为 O(n)。此外，顺序表需要预分配存储空间，这可能导致空间的浪费或不足。</p>
<h5 id="链表的特点"><a href="#链表的特点" class="headerlink" title="链表的特点"></a>链表的特点</h5><p>链表的优点在于<strong>插入和删除操作非常高效</strong>，因为这些操作<strong>只涉及到改变指针的指向，而不需要移动其他元素</strong>，时间复杂度为 O(1)。链表的存储空间是动态分配的，这意味着它可以根据需要扩展和收缩，避免了空间浪费或不足的问题。然而，链表的缺点是不能直接通过下标索引来访问元素，必须从头节点开始遍历，这使得访问效率较低，时间复杂度为 O(n)。此外，由于每个节点都需要一个额外的指针空间，链表的存储密度低于顺序表。</p>
<h4 id="2-线性表简单应用"><a href="#2-线性表简单应用" class="headerlink" title="2.线性表简单应用"></a>2.线性表简单应用</h4><p>线性表的应用非常广泛，它不仅可以用于表示一组有序的数据集合，还可以用于实现各种复杂的数据结构和算法，可以解决很多实际问题，如 <a href="https://juejin.cn/post/7014325372502147109?searchId=20250908213508C8F0E7777DE9D8848F82">一元多项式的运算</a> ， <a href="https://juejin.cn/post/7149560476047769637?searchId=20250908213310701F9AE735E4B83FEECC">约瑟夫环问题</a>等。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
